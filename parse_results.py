#!/usr/bin/env python3
"""
Parses the raw output file generated by the 'Collect Results' step
in the dynamic workflow run by 'act'. This output contains a non-standard
representation of the GitHub Actions 'steps' context.
"""

import sys
import json
import yaml
import re
import io
from typing import Dict, Any, Optional, List, Tuple

def _extract_outcome(step_lines: List[str]) -> str:
    """Extracts the outcome value from lines belonging to a single step."""
    outcome_regex = re.compile(r'^\s{4}outcome:\s*(\w+),?')
    for line in step_lines:
        match = outcome_regex.match(line)
        if match:
            return match.group(1)
    return "unknown"

def _extract_outputs_json(step_lines: List[str]) -> Dict[str, Any]:
    """Extracts and parses the outputs block from lines belonging to a single step."""
    outputs_start_regex = re.compile(r'^\s{4}outputs:\s*\{')
    in_outputs_block = False
    outputs_str_lines = []
    brace_level = 0

    for line in step_lines:
        if outputs_start_regex.match(line):
            in_outputs_block = True
            # Handle empty inline object: "outputs: {}"
            if line.strip().endswith('{}'):
                return {}
            brace_level = 1
            continue # Skip the starting line itself

        if in_outputs_block:
            # Track braces to find the end
            brace_level += line.count('{')
            brace_level -= line.count('}')

            # Add line content (removing outer indentation) if still inside
            if brace_level > 0 or (brace_level == 0 and line.count('{') > 0):
                 # Assuming 6 spaces indent for content inside outputs: {}
                 outputs_str_lines.append(line[6:] if len(line) > 6 else line.strip())

            if brace_level <= 0:
                break # End of block

    # Attempt to parse the collected outputs string
    outputs_str = "".join(outputs_str_lines)
    if not outputs_str.strip():
        return {}
    try:
        # Add braces back and parse as JSON
        return json.loads("{" + outputs_str + "}")
    except json.JSONDecodeError:
        print(f"::warning::Could not parse outputs block: {{{outputs_str}}}", file=sys.stderr)
        return {} # Default to empty dict on error

def parse_raw_results(raw_content: str) -> Dict[str, Dict[str, Any]]:
    """
    Parses the raw, potentially non-standard JSON/YAML output from act's toJSON(steps).
    Extracts outcome and outputs for each step ID found.

    Args:
        raw_content: The string content read from the results file.

    Returns:
        A dictionary where keys are step IDs and values are dictionaries
        containing 'outcome' and 'outputs'.
    """
    steps_data: Dict[str, Dict[str, Any]] = {}
    current_step_lines: List[str] = []
    current_step_id: Optional[str] = None
    # Regex to find step ID lines (e.g., "  step_id:")
    step_id_regex = re.compile(r'^\s{2}([a-zA-Z0-9_.-]+):')

    for line in io.StringIO(raw_content):
        step_match = step_id_regex.match(line)
        if step_match:
            # Process the previous step's collected lines
            if current_step_id and current_step_lines:
                outcome = _extract_outcome(current_step_lines)
                outputs = _extract_outputs_json(current_step_lines)
                steps_data[current_step_id] = {'outcome': outcome, 'outputs': outputs}

            # Start new step
            current_step_id = step_match.group(1)
            current_step_lines = [line] # Start collecting lines for the new step
            if current_step_id not in steps_data: # Initialize if not seen
                 steps_data[current_step_id] = {'outcome': 'unknown', 'outputs': {}}
        elif current_step_id:
            # Continue collecting lines for the current step
            current_step_lines.append(line)

    # Process the very last step's collected lines
    if current_step_id and current_step_lines:
        outcome = _extract_outcome(current_step_lines)
        outputs = _extract_outputs_json(current_step_lines)
        # Ensure entry exists even if only ID line was present
        if current_step_id not in steps_data:
             steps_data[current_step_id] = {'outcome': 'unknown', 'outputs': {}}
        steps_data[current_step_id]['outcome'] = outcome
        steps_data[current_step_id]['outputs'] = outputs

    return steps_data

def main():
    """Main execution function."""
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <results_file> <id_index_map_file> <merged_actions_yaml_file>", file=sys.stderr)
        sys.exit(1)

    results_file_path = sys.argv[1]
    id_index_map_file_path = sys.argv[2]
    merged_actions_yaml_file_path = sys.argv[3]

    # --- Read Input Files ---
    try:
        with open(results_file_path, 'r', encoding='utf-8') as f:
            raw_results_content = f.read()
    except FileNotFoundError:
        print(f"::error::Results file not found at {results_file_path}", file=sys.stderr)
        print("[]") # Output empty JSON array on error
        sys.exit(0) # Exit gracefully for the action
    except Exception as e:
        print(f"::error::Failed to read results file {results_file_path}: {e}", file=sys.stderr)
        print("[]")
        sys.exit(0)

    try:
        with open(id_index_map_file_path, 'r', encoding='utf-8') as f:
            id_index_map = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"::warning::ID->Index map file not found or invalid at {id_index_map_file_path}: {e}", file=sys.stderr)
        id_index_map = {} # Continue with an empty map

    try:
        with open(merged_actions_yaml_file_path, 'r', encoding='utf-8') as f:
            # Use safe_load to avoid potential arbitrary code execution
            merged_actions = yaml.safe_load(f)
            if not isinstance(merged_actions, list):
                print(f"::warning::Merged actions file {merged_actions_yaml_file_path} did not contain a list.", file=sys.stderr)
                merged_actions = [] # Ensure it's a list
    except (FileNotFoundError, yaml.YAMLError) as e:
        print(f"::warning::Merged actions YAML file not found or invalid at {merged_actions_yaml_file_path}: {e}", file=sys.stderr)
        merged_actions = [] # Continue with empty actions list

    # --- Parse Raw Results ---
    parsed_steps_data = parse_raw_results(raw_results_content)

    # --- Combine Data ---
    final_results = []
    all_step_ids = list(parsed_steps_data.keys()) # Process all steps found in results

    for step_id in all_step_ids:
        step_data = parsed_steps_data[step_id]
        step_index = id_index_map.get(step_id) # Returns None if ID not in map

        name = step_id # Default name is the step ID
        uses = None

        if step_index is not None:
            try:
                if step_index < len(merged_actions):
                    original_action = merged_actions[step_index]
                    if isinstance(original_action, dict):
                        extracted_name = original_action.get('name')
                        extracted_uses = original_action.get('uses')

                        # Determine display name
                        if extracted_name:
                            name = str(extracted_name).strip()
                        elif extracted_uses: # Generate default name if needed
                            name = f"Run {extracted_uses}".strip()
                        elif original_action.get('run'):
                            name = f"Run script {step_index}".strip()
                        # else: keep step_id as name if no info found

                        uses = extracted_uses # Will be None if not a 'uses' step
                else:
                     print(f"::warning::Index {step_index} for step {step_id} out of bounds for merged_actions (len={len(merged_actions)}).", file=sys.stderr)
            except Exception as e:
                 print(f"::warning::Error processing original action data for step {step_id} at index {step_index}: {e}", file=sys.stderr)


        final_results.append({
            "id": step_id,
            "name": name,
            "uses": uses,
            "outcome": step_data.get('outcome', 'unknown'),
            "outputs": step_data.get('outputs', {})
        })

    # --- Output Final JSON ---
    try:
        print(json.dumps(final_results, indent=2))
    except Exception as e:
        print(f"::error::Failed to serialize final results to JSON: {e}", file=sys.stderr)
        print("[]") # Output empty array on final error


if __name__ == "__main__":
    main()
